# Models

```{r, warning = FALSE}
# Upload the data
setwd(here::here("data/"))
GermanCredit <- read_csv("GermanCreditClean.csv")
```

After the exploration of our data, we start with the modelling part.

## Splitting strategies

In order to test the performance of our models, we use a splitting strategy of the dataset:

- 80% is used as a training set
- The remaining 20% is used as a test set.

```{r}
# Creation of the training and splitting data set
set.seed(346) # To get the same results
index.tr <- createDataPartition(y = GermanCredit$RESPONSE, p= 0.8, list = FALSE) #Creation of the index
GermanCredit.tr <- GermanCredit[index.tr,] # Training set
GermanCredit.te <- GermanCredit[-index.tr,] # Testing set
```

## Balance the dataset

As said in the exploratory data analysis, we notice that our data is heavily unbalanced. We need to balance it before fitting our model. 

```{r, results='hide'}
# Balancing the training set
table(GermanCredit.tr$RESPONSE)

n <- min(table(GermanCredit.tr$RESPONSE))

GermanCredit.tr.no <- filter(GermanCredit.tr, as_factor(RESPONSE)==0)
GermanCredit.tr.yes <- filter(GermanCredit.tr, as_factor(RESPONSE)==1)

index.no <- sample(size=n, x=1:nrow(GermanCredit.tr.no), replace=FALSE) ## sub-sample 236 instances from the "Yes"

GermanCredit.tr.subs <- data.frame(rbind(GermanCredit.tr.no, GermanCredit.tr.yes[index.no,])) ## Bind all the "No" and the sub-sampled "Yes"
table(GermanCredit.tr.subs$RESPONSE) ## The cases are balanced
```

## Logistic Regression

We fit a logistic regression to test if it could predict the output we desired.

For our first model we'll select all the variables given in the German Credit data set.

```{r, results = 'hide'}
mod.logr <- glm(as_factor(RESPONSE)~., data = GermanCredit.tr.subs, family="binomial")
summary(mod.logr)
```

Our initial model is therefore:

$$
z_i = a_o + a_1{CHKACCT}_{31i} + ... + a_{31}Foreign_{31i}
$$

Selection of the model

```{r, results = 'hide'}
# Using the AIC
mod.logr.sel <- step(mod.logr) # Here by default, backwards selection
summary(mod.logr.sel) # Reminder, the lower the AIC the better
```

Final model:

$$
z_i = a_o + a_1{CHKACCT}_{1i} + a_2{DURATION}_{2i} + a_3{HISTORY}_{3i} + a_4{NEWCAR}_{4i} +  a_4{USEDCAR}_{4i} + a_5{AMOUNT}_{5i} + a_6{SAVACCT}_{6i} + a_7{EMPLOYMENT}_{7i} + a_8{INSTALLRATE}_{8i} + a_9{MALSINGLE}_{9i} + a_10{CO-APPLICANT}_{10i} + a_11{GUARANTOR}_{11i} + a_12{REALESTATE}_{12i} + a_13{OTHERINSTALL}_{13i} + a_14{OWNRES}_{14i} + a_15{NUMCREDITS}_{15i} + a_16{NUMDEPENDENTS}_{16i} + a_17{FOREIGN}_{17i}      
$$
Predictions: 

```{r, results = 'hide'}
prob.te <- predict(mod.logr.sel, newdata=GermanCredit.te, type="response")
pred.te <- ifelse(prob.te >= 0.5, 1, 0)
table(Pred=pred.te, Obs=GermanCredit.te$RESPONSE)

cm<-confusionMatrix(spam.pred, spam$yesno)
cm

draw_confusion_matrix(cm)
```

```{r, results = 'hide'}
draw_confusion_matrix <- function(cm) {
  
  layout(matrix(c(1,1,2)))
  par(mar=c(2,2,2,2))
  plot(c(100, 345), c(300, 450), type = "n", xlab="", ylab="", xaxt='n', yaxt='n')
  title('CONFUSION MATRIX', cex.main=2)
  
  # create the matrix 
  rect(150, 430, 240, 370, col='#3F97D0')
  text(195, 435, 'Class1', cex=1.2)
  rect(250, 430, 340, 370, col='#F7AD50')
  text(295, 435, 'Class2', cex=1.2)
  text(125, 370, 'Predicted', cex=1.3, srt=90, font=2)
  text(245, 450, 'Actual', cex=1.3, font=2)
  rect(150, 305, 240, 365, col='#F7AD50')
  rect(250, 305, 340, 365, col='#3F97D0')
  text(140, 400, 'Class1', cex=1.2, srt=90)
  text(140, 335, 'Class2', cex=1.2, srt=90)
  
  # add in the cm results 
  res <- as.numeric(cm$table)
  text(195, 400, res[1], cex=1.6, font=2, col='white')
  text(195, 335, res[2], cex=1.6, font=2, col='white')
  text(295, 400, res[3], cex=1.6, font=2, col='white')
  text(295, 335, res[4], cex=1.6, font=2, col='white')
  
  # add in the specifics 
  plot(c(100, 0), c(100, 0), type = "n", xlab="", ylab="", main = "DETAILS", xaxt='n', yaxt='n')
  text(10, 85, names(cm$byClass[1]), cex=1.2, font=2)
  text(10, 70, round(as.numeric(cm$byClass[1]), 3), cex=1.2)
  text(30, 85, names(cm$byClass[2]), cex=1.2, font=2)
  text(30, 70, round(as.numeric(cm$byClass[2]), 3), cex=1.2)
  text(50, 85, names(cm$byClass[5]), cex=1.2, font=2)
  text(50, 70, round(as.numeric(cm$byClass[5]), 3), cex=1.2)
  text(70, 85, names(cm$byClass[6]), cex=1.2, font=2)
  text(70, 70, round(as.numeric(cm$byClass[6]), 3), cex=1.2)
  text(90, 85, names(cm$byClass[7]), cex=1.2, font=2)
  text(90, 70, round(as.numeric(cm$byClass[7]), 3), cex=1.2)
  
  # add in the accuracy information 
  text(30, 35, names(cm$overall[1]), cex=1.5, font=2)
  text(30, 20, round(as.numeric(cm$overall[1]), 3), cex=1.4)
  text(70, 35, names(cm$overall[2]), cex=1.5, font=2)
  text(70, 20, round(as.numeric(cm$overall[2]), 3), cex=1.4)
}
```

```{r}
prob_glm_aic <- predict(mod.logr.sel, newdata = GermanCredit.te, type = "response")
pred_glm_aic <- ifelse(prob_glm_aic >= 0.5, 1, 0)
cm_glm_aic <- confusionMatrix(data = as.factor(pred_glm_aic), reference = as.factor(GermanCredit.te$RESPONSE))
draw_confusion_matrix(cm_glm_aic)
```

Not a good model. Do not forget that the prior of this data set is not balanced at all. We should take it into account.

As depicted below, if our model was good, we should have boxplot that are far away from the 0.5, which is not the case, especially for the bad credits.

```{r}
boxplot(prob.te~GermanCredit.te$RESPONSE)
```

### Cross-validation

```{r, results = 'hide'}
trctrl <- trainControl(method = "cv", number=10)

set.seed(346)
GermanCredit.cv <- train(as_factor(RESPONSE) ~., data = GermanCredit.tr.subs, method = "glmStepAIC", family="binomial",
                    trControl=trctrl, trace=0)

GermanCredit.cv
```

```{r, results = 'hide'}
GermanCredit.pred <- predict(GermanCredit.cv, newdata = GermanCredit.te)
confusionMatrix(data=GermanCredit.cv, reference = GermanCredit.te$RESPONSE)
```

